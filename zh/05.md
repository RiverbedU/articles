假设我们的最基本的数据结构是文档，用户通过编写文档来讨论问题。例如在下面这个文档，用户A提出了一个问题，然后给出了自己的回答：

```
[Question#1a] 某某现象是如何造成的？

因为ABCDE
```

然后另一个用户B也想参与到这个问题的讨论，那么他也会需要写一个文档：

```
[Question#1b] 某某现象是如何造成的？

因为FGHIJ
```

一般我们可以知道1a和1b其实是同一个问题，所以我们希望这两个文档被联系起来，这样当我们点击这个问题的时候，两个文档都可以被找出来。要做到这点，我们需要让这个问题可以被引用。

第一种方式是，当用户A提出一个问题的时候，就把这个问题加入一个全局的问题库，然后自己再引用这个全局的问题，然后再写自己的回答。但是这样的问题是，A把自己的问题建成全局之后，理论上自己也不再能更改这个问题，因为一旦更改了，其他依赖这个问题的文档都会坏掉。

如果这个问题在起始阶段只有A在用，那么这个做法显然是不合理的，因为A自己在讨论的时候可能需要经常修改问题，来让它变得更准确。另一种做法是，仅当有多个人想讨论同一个问题的时候，把这个问题建立成一个独立的实体。但这种做法看起来很奇怪。

如果要在多人的干涉下把一个问题建立成一个公共的实体，那么我们需要有一种规则指导实体的编辑，它不能是任意的，而是必须是没有破坏性的改动。这就可能会用到社区投票，来保障一个社区认可的表述。

如果不考虑社区维护的问题，我们可以让B自负风险引用A的问题，例如：

```
[Question@A#1a]

因为FGHIJ
```

这样明确引用了A的问题，当A发生改动的时候，这里也会发生改动。但是这样可以确保，点击这个问题的时候还是会跳回A的问题，这样两个文档就被联系了起来。

如果要防止A改动的时候B也跟着改动，可以进一步在引用的时候加上历史版本。如：

```
[Question@A#1a:2021]

因为FGHIJ
```

这样无论A那边如何变化，B的文档都不会损坏，而如果A变化了，B可以收到一个提示，询问要不要跟着更新A的引用。

如果B想要更改这个问题呢？如果他直接删掉对A的引用，直接使用自己的文本，这样就会和原问题脱离而没办法索引到 。如果B要更改，他可能最好是建立一个新的版本，如`[Question@B#1b]`，但是我们的系统里知道这个是从`[Question@A#1a:2021]`这里分支出来的。这样在找相关问题的时候，还是可以从这个问题修改去获取A的文档。

如果要维护文档中一个实体的版本信息，我们会没办法使用纯文本管理文档。原本我们可能可以直接把每个文档考虑成纯文本或者一个代码文件，但是代码文件没办法追踪文档中的实体的变动，电脑无法自动把`[Question@B#1b]`和`[Question@A#1a:2021]`联系起来，而知道前者是由后者那来的。或者电脑可以做一些猜测，但是出错机率可能很大。

#### 究竟是不是要这么复杂？

搜索引擎：不用。搜索引擎只需要按相同的问题执行一次搜索，即可找到相关的内容，而不需要实际的引用结构。但是后果就是这种搜索结果的相关度没办法保证。
